//
//  GeneratorTests.swift
//  BeaverDICodeGenTests
//
//  Created by Th√©ophane Rupin on 3/4/18.
//

import Foundation
import XCTest
import SourceKittenFramework

@testable import BeaverDICodeGen

final class GeneratorTests: XCTestCase {
    
    func testGeneratorShouldGenerateAValidSwiftCode() {
        
        do {
            let file = File(contents: """
// beaverdi: parent = MainDependencyResolver
final class MyService {
  let dependencies: DependencyResolver

  // beaverdi: api = API <- APIProtocol
  // beaverdi: api.scope = .graph

  // beaverdi: router = Router <- RouterProtocol
  // beaverdi: router.scope = .parent

  // beaverdi: parent = MyServiceDependencyResolver
  final class MyEmbeddedService {

    // beaverdi: session = Session? <- SessionProtocol?
    // beaverdi: session.scope = .container
  }

  init(_ dependencies: DependencyResolver) {
    self.dependencies = dependencies
  }
}

class AnotherService {
    // This class is ignored
}
""")
            
            let lexer = Lexer(file)
            let tokens = try lexer.tokenize()
            let parser = Parser(tokens)
            let syntaxTree = try parser.parse()

            let input = DataInputMock()
            
            let generator = Generator(template: "dependency_resolver")
            try generator.generate(in: input, ast: syntaxTree)
            
            XCTAssertEqual(input.string!, """
/// This file is generated by BeaverDI
/// DO NOT EDIT!


// MARK: - MyService

final class MyServiceDependencyResolver: DependencyResolver {
  
  init(_ parent: MainDependencyResolver) {
    super.init(parent)
  }

  override func registerDependencies(in store: DependencyStore) {
    
    store.register(APIProtocol.self, scope: .graph, builder: { dependencies in
      return API.makeAPI(injecting: dependencies)
    })
    
    store.register(RouterProtocol.self, scope: .parent, builder: { dependencies in
      return Router.makeRouter(injecting: dependencies)
    })
    
  }
}

extension MyService {

  // MARK: - Builder

  static func makeMyService(injecting parentDependencies: MainDependencyResolver) -> MyService {
    let dependencies = MyServiceDependencyResolver(parentDependencies)
    return MyService(injecting: dependencies)
  }

  // MARK: - Resolver utils
  
  var api: APIProtocol {
    return dependencies.resolve(APIProtocol.self)
  }
  
  var router: RouterProtocol {
    return dependencies.resolve(RouterProtocol.self)
  }
  
}

// MARK: - MyEmbeddedService

final class MyEmbeddedServiceDependencyResolver: DependencyResolver {
  
  init(_ parent: MyServiceDependencyResolver) {
    super.init(parent)
  }

  override func registerDependencies(in store: DependencyStore) {
    
    store.register(SessionProtocol?.self, scope: .container, builder: { dependencies in
      return Session.makeSession(injecting: dependencies)
    })
    
  }
}

extension MyService.MyEmbeddedService {

  // MARK: - Builder

  static func makeMyEmbeddedService(injecting parentDependencies: MyServiceDependencyResolver) -> MyEmbeddedService {
    let dependencies = MyEmbeddedServiceDependencyResolver(parentDependencies)
    return MyEmbeddedService(injecting: dependencies)
  }

  // MARK: - Resolver utils
  
  var session: SessionProtocol? {
    return dependencies.resolve(SessionProtocol?.self)
  }
  
}

""")
            
        } catch {
            XCTFail("Unexpected error \(error)")
        }
    }
}
