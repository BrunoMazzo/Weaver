/// This file is generated by BeaverDI
/// DO NOT EDIT!

import BeaverDI
{% for resolver in resolvers %}
// MARK: - {{resolver.targetTypeName}}

final class {{resolver.targetTypeName}}DependencyContainer: DependencyContainer {

    {% for parameter in resolver.parameters %}let {{parameter.name}}: {{parameter.typeName}}
    {% endfor %}
    init({% if not resolver.isRoot %}parent: DependencyContainer{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) {
        {% for parameter in resolver.parameters %}self.{{parameter.name}} = {{parameter.name}}
        {% endfor %}super.init({% if not resolver.isRoot %}parent{% endif %})
    }

    override func registerDependencies(in store: DependencyStore) {
        {% for registration in resolver.registrations %}
        store.register({{registration.abstractTypeName}}.self, scope: .{{registration.scope}}, name: "{{registration.name}}", builder: { (dependencies{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.typeName}}{% endfor %}) in
            {% if not registration.isCustom %}return {{registration.typeName}}.make{{registration.typeName}}(injecting: dependencies{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.name}}{% endfor %}){% else %}return self.{{registration.name}}CustomRef(dependencies{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.name}}{% endfor %}){% endif %}
        }){% endfor %}
    }
}

protocol {{resolver.targetTypeName}}DependencyResolver {
    {% for parameter in resolver.parameters %}var {{parameter.name}}: {{parameter.typeName}} { get }
    {% endfor %}
    {% for reference in resolver.references %}{% if reference.parameters %}
    func {{reference.name}}({% for parameter in reference.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{reference.typeName}}
    {% else %}
    var {{reference.name}}: {{reference.typeName}} { get }{% endif %}{% endfor %}
    {% for registration in resolver.registrations %}{% if registration.isCustom %}func {{registration.name}}CustomRef(_ dependencies: DependencyContainer{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.typeName}}{% endfor %}) -> {{registration.abstractTypeName}}
    {% endif %}{% endfor %}
}

extension {{resolver.targetTypeName}}DependencyContainer: {{resolver.targetTypeName}}DependencyResolver {
    {% for reference in resolver.references %}{% if reference.parameters %}
    func {{reference.name}}({% for parameter in reference.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{reference.typeName}} {
        return resolve({{reference.typeName}}.self, name: "{{reference.name}}", parameter{% if reference.parameters.count > 1 %}s{% endif %}: {% for parameter in reference.parameters %}{{parameter.name}}{% if not forloop.last %}, {% endif %}{% endfor %})
    }
    {% else %}
    var {{reference.name}}: {{reference.typeName}} {
        return resolve({{reference.typeName}}.self, name: "{{reference.name}}")
    }{% endif %}{% endfor %}
}{% if not resolver.isRoot %}

extension {% if resolver.enclosingTypeNames %}{{resolver.enclosingTypeNames|join: "."}}.{% endif %}{{resolver.targetTypeName}} {

    static func make{{resolver.targetTypeName}}({% if not resolver.isRoot %}injecting parentDependencies: DependencyContainer{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{resolver.targetTypeName}} {
        let dependencies = {{resolver.targetTypeName}}DependencyContainer({% if not resolver.isRoot %}parent: parentDependencies{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.name}}{% if not forloop.last %}, {% endif %}{% endfor %})
        return {{resolver.targetTypeName}}(injecting: dependencies)
    }
}{% endif %}{% if not resolver.isRoot %}

protocol {{resolver.targetTypeName}}DependencyInjectable {
    init(injecting dependencies: {{resolver.targetTypeName}}DependencyResolver)
}

extension {% if resolver.enclosingTypeNames %}{{resolver.enclosingTypeNames|join: "."}}.{% endif %}{{resolver.targetTypeName}}: {{resolver.targetTypeName}}DependencyInjectable {}{% endif %}
{% endfor %}