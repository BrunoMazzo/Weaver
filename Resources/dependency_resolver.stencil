/// This file is generated by BeaverDI
/// DO NOT EDIT!

import BeaverDI
{% for resolver in resolvers %}
// MARK: - {{resolver.targetTypeName}}

final class {{resolver.targetTypeName}}DependencyContainer: DependencyContainer {

    init({% if not resolver.isRoot %}_ parent: DependencyContainer{% endif %}) {
        super.init({% if not resolver.isRoot %}parent{% endif %})
    }

    override func registerDependencies(in store: DependencyStore) {
        {% for registration in resolver.registrations %}
        store.register({{registration.abstractTypeName}}.self, scope: .{{registration.scope}}, name: "{{registration.name}}", builder: { dependencies in
            {% if not registration.isCustom %}return {{registration.typeName}}.make{{registration.typeName}}(injecting: dependencies){% else %}return self.{{registration.name}}CustomRef(dependencies){% endif %}
        }){% endfor %}
    }
}

protocol {{resolver.targetTypeName}}DependencyResolver {
    {% for reference in resolver.references %}
    var {{reference.name}}: {{reference.typeName}} { get }{% endfor %}
    {% for registration in resolver.registrations %}{% if registration.isCustom %}func {{registration.name}}CustomRef(_ dependencies: DependencyContainer) -> {{registration.abstractTypeName}}
    {% endif %}{% endfor %}
}

extension {{resolver.targetTypeName}}DependencyContainer: {{resolver.targetTypeName}}DependencyResolver {
    {% for reference in resolver.references %}
    var {{reference.name}}: {{reference.typeName}} {
        return resolve({{reference.typeName}}.self, name: "{{reference.name}}")
    }{% endfor %}
}{% if not resolver.isRoot %}

extension {% if resolver.enclosingTypeNames %}{{resolver.enclosingTypeNames|join: "."}}.{% endif %}{{resolver.targetTypeName}} {

    static func make{{resolver.targetTypeName}}({% if not resolver.isRoot %}injecting parentDependencies: DependencyContainer{% endif %}) -> {{resolver.targetTypeName}} {
        let dependencies = {{resolver.targetTypeName}}DependencyContainer({% if not resolver.isRoot %}parentDependencies{% endif %})
        return {{resolver.targetTypeName}}(injecting: dependencies)
    }
}{% endif %}{% if not resolver.isRoot %}

protocol {{resolver.targetTypeName}}DependencyInjectable {
    init(injecting dependencies: {{resolver.targetTypeName}}DependencyResolver)
}

extension {% if resolver.enclosingTypeNames %}{{resolver.enclosingTypeNames|join: "."}}.{% endif %}{{resolver.targetTypeName}}: {{resolver.targetTypeName}}DependencyInjectable {}{% endif %}
{% endfor %}