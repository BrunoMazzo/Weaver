/// This file is generated by Weaver
/// DO NOT EDIT!

import Weaver
{% for resolver in resolvers %}
// MARK: - {{resolver.targetTypeName}}

{% if resolver.isPublic %}public {% endif %}final class {{resolver.targetTypeName}}DependencyContainer: DependencyContainer {
    {% for parameter in resolver.parameters %}
    let {{parameter.name}}: {{parameter.typeName}}
    {% endfor %}
    {% if resolver.isPublic %}public {% endif %}init({% if not resolver.isRoot %}parent: DependencyContainer{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) {
        {% for parameter in resolver.parameters %}
        self.{{parameter.name}} = {{parameter.name}}
        {% endfor %}
        super.init({% if not resolver.isRoot %}parent{% endif %})
    }

    override {% if resolver.isPublic %}public {% endif %}func registerDependencies(in store: DependencyStore) {
        {% for registration in resolver.registrations %}
        store.register({{registration.abstractTypeName}}.self, scope: .{{registration.scope}}, name: "{{registration.name}}", builder: { (dependencies{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.typeName}}{% endfor %}) in{% if not registration.isCustom %}
            return {{registration.typeName}}.make{{registration.typeName}}(injecting: dependencies{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.name}}{% endfor %}){% else %}
            return self.{{registration.name}}CustomRef(dependencies{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.name}}{% endfor %}){% endif %}
        })
        {% endfor %}
    }
}

{% if resolver.isPublic %}public {% endif %}protocol {{resolver.targetTypeName}}DependencyResolver {
    {% for parameter in resolver.parameters %}
    var {{parameter.name}}: {{parameter.typeName}} { get }
    {% endfor %}

    {% for reference in resolver.references %}{% if reference.parameters %}
    func {{reference.name}}({% for parameter in reference.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{reference.resolvedTypeName}}
    {% else %}
    var {{reference.name}}: {{reference.resolvedTypeName}} { get }
    {% endif %}
    {% endfor %}

    {% for registration in resolver.registrations %}
    {% if registration.isCustom %}
    func {{registration.name}}CustomRef(_ dependencies: DependencyContainer{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.typeName}}{% endfor %}) -> {{registration.abstractTypeName}}
    {% endif %}
    {% endfor %}
}

extension {{resolver.targetTypeName}}DependencyContainer: {{resolver.targetTypeName}}DependencyResolver {
    {% for reference in resolver.references %}
    {% if reference.parameters %}
    {% if resolver.isPublic %}public {% endif %}func {{reference.name}}({% for parameter in reference.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{reference.resolvedTypeName}} {
        return resolve({{reference.resolvedTypeName}}.self, name: "{{reference.name}}", parameter{% if reference.parameters.count > 1 %}s{% endif %}: {% for parameter in reference.parameters %}{{parameter.name}}{% if not forloop.last %}, {% endif %}{% endfor %})
    }
    {% else %}
    {% if resolver.isPublic %}public {% endif %}var {{reference.name}}: {{reference.resolvedTypeName}} {
        return resolve({{reference.resolvedTypeName}}.self, name: "{{reference.name}}")
    }
    {% endif %}
    {% endfor %}
}

{% if not resolver.isRoot %}
extension {% if resolver.enclosingTypeNames %}{{resolver.enclosingTypeNames|join: "."}}.{% endif %}{{resolver.targetTypeName}} {

    {% if resolver.isPublic %}public {% endif %}static func make{{resolver.targetTypeName}}({% if not resolver.isRoot %}injecting parentDependencies: DependencyContainer{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{resolver.targetTypeName}} {
        let dependencies = {{resolver.targetTypeName}}DependencyContainer({% if not resolver.isRoot %}parent: parentDependencies{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.name}}{% if not forloop.last %}, {% endif %}{% endfor %})
        return {{resolver.targetTypeName}}(injecting: dependencies)
    }
}

{% if resolver.isPublic %}public {% endif %}protocol {{resolver.targetTypeName}}DependencyInjectable {
    init(injecting dependencies: {{resolver.targetTypeName}}DependencyResolver)
}

extension {% if resolver.enclosingTypeNames %}{{resolver.enclosingTypeNames|join: "."}}.{% endif %}{{resolver.targetTypeName}}: {{resolver.targetTypeName}}DependencyInjectable {}
{% endif %}
{% endfor %}
